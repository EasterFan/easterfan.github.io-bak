---
title: Java整理 - 多线程
tags: Java 多线程
---

> 今天重温线程，惊奇的发现以前的练习已经完全看不懂了，我是时候该写一点便于记忆的带有情感的文字，好让它能在我的脑子里停留的更久一点

<!--more-->
## 一. 多线程是什么
### 本质
多线程的本质是什么？  
我们先要理解**进程**和**线程**的关系。进程是由多个线程组成的。  

当你一边唱歌一边跳舞时，你就看到了**多进程**，唱歌是一个进程，嘴巴开合是一个线程，声带震动发声是一个线程，这两个**线程**同时工作，就有了唱歌这个**进程**；同样，跳舞是一个进程，手舞是一个线程，足蹈是一个线程，这两个**线程**同时工作，就有了跳舞这个**进程**。  

多线程的本质，不妨理解成，多个小动作同时进行，完成一个大动作。  

### 意义

对于CPU而言(单核)，在一个时间片上只能执行一个动作，我们看到QQ和网易云同时在运行，实际上是依次执行QQ和网易云的线程，只不过CPU切换的时间非常短暂，给肉眼一种同时在运行的错觉。  

java引入多线程，是为了充分利用CPU资源，提高程序运行效率。  

你为什么一边唱歌一边跳舞？也许是为了充分利用生命有限的时间。  

### 特点

1. 随机性  
因为有多个线程都在争夺CPU的执行权，CPU执行到谁，谁就运行，在某一时刻，只能有一个线程在运行.  
所以多线程程序，每一次运行的结果都不同，具有随机性

2. 锁机制  
同步函数的锁是this，两个同步方法，应该使用同一个锁来保证线程安全  
静态同步函数的锁是class对象，因为静态函数进入内存时还没有对象，只有类的字节码文件对象

### 管理

当一个对象承载了很多功能的时候，他就该学习怎样去合理而有序的管理自己的功能，多线程同时执行的数目越多，线程就越不安全。  

比如玩手机和过马路这两个线程即将同时运行时，这个对象会告诉自己:先过马路，再看手机。等到了马路的另一边的时候，这个对象再告诉自己，现在可以执行看手机线程了。  

java中，通过**同步**和**通信**这两种方式来进行多线程管理，  

同步，是为了保证多个线程在某一时刻只执行一个线程，比如你在过马路时，全身上下只有过马路这一个线程在执行，其他线程处于休眠状态  

通信，是指一个线程执行完毕后，唤醒其他线程继续执行。比如你过完马路后，唤醒看手机线程、唱歌线程继续执行。  


同步是为了让线程单独的使用共享对象，  
通信是为了让线程有序的使用共享对象  


同步通过**锁机制**(synchronised)，当一个线程占有共享对象时，其它线程都不能进入该共享对象，当线程执行结束后，其它对象才可进入，确保在某一时刻，只有一个线程在单独使用共享对象。  

通信通过**等待唤醒机制**，阻塞当前线程，执行结束后，唤醒线程，继续执行，确保多个线程能够按照顺序有序的使用CPU。  

## 二. 多线程管理 - 同步
> 多线程通过锁的方式，实现同步--synchronised

### 同步的本质
通过加锁机制，当一个线程在操作共享对象时其它线程不能操作该共享对象，确保在某一时间点，只有一个线程单独占用共享对象。

### 同步的内容
多个线程之间通过争抢CPU资源获得执行权，当多个线程共享同一个对象时，争抢会带来数据混乱。  
如果食堂阿姨是一个共享对象，每个学生是一个线程, 在某一时刻, 阿姨都是在给一位同学打饭, 前一个同学离开后, 继续为下一位同学打饭, 这个过程就是同步的过程, 这个同步过程中的锁, 就是学生的排队意识, 一个线程看到前面有学生正在打饭, 本能驱使他去争抢执行权, 排队意识(锁)告诉他这个时候不能去抢, 于是最后表现是这位同学主动排队等候.

### 同步的意义
保证数据一致性。  

线程没有加锁同步的时候, 多个线程公平争抢 CPU 执行权, 争抢会带来数据不一致的风险, 就像食堂阿姨同时为多位同学打饭, 手忙脚乱中就会出现"饭不对号"的风险, 比如把小明的口水鸡错当成小王的脆皮鸭打包给小红.  

同步可以避免数据不一致的风险, 但每个线程都要判断一次锁, 显然, 这是在牺牲了一点时间效率的前提下.

### 同步的弊端 -- 死锁
同步还有一个要命的弊端 -- 死锁, 死锁是什么? 什么情况下会发生死锁? 怎样避免死锁?  
当一个程序中所有线程全都处于等待状态(线程仍然活着)时, 程序并没有退出, 而是整个程序都卡住了(A线程在等B线程执行, B线程在等C线程执行,C线程在等...), 这个状态, 就是死锁.  

同步中, **锁中套锁**的情况下, 最容易出现死锁:  

```java
  @Override
    public void run() {
        if(flag){
            // A 中 锁 B
            synchronized (Lock.locka){
                System.out.println("if locka");

                synchronized (Lock.lockb){
                    System.out.println("if lockb");
                }
            }
        }else {
            // B 中锁 A
            synchronized (Lock.lockb){
                System.out.println("else lockb");

                synchronized (Lock.locka){
                    System.out.println("else locka");
                }
            }
        }
    }
```
怎样避免死锁? 发生死锁的原因是因为所有线程都处于等待状态, 让这些线程都从等待中醒过来, 死锁就可以解除了, 怎样唤醒线程? 这就涉及线程管理的第二部分 ---> **线程通信**


## 三. 多线程管理 - 通信
> 等待唤醒机制

线程通信中, 一个通用的例子是生产者和消费者的例子, 假设只有一个生产者和一个消费者, 要求先生产, 后消费, 生产一个消费一个.  

```java
 // 录入人员信息
  public synchronized void RoomIn(String name,String sex){
      // 如果有人，放弃执行权，进行等待
      if(flag) {
          try {wait();} catch (InterruptedException e) {e.printStackTrace();}  // 线程很有可能在这里阻塞,然后醒来
      }
      // 如果没人，进行录入
      this.name = name;
      this.sex = sex;
      System.out.println(Thread.currentThread().getName() + ".....RoomIn:" + this.name+"....."+this.sex);
      flag = true;
      // 用来唤醒前面被 wait 的线程
      notify();
}
```
上面这段代码块成立的条件是:**一个生产者,一个消费者**  
如果有多个生产者, 多个消费者, 会出现什么情况?  
生产者线程 A 进入 RoomIn 后, 在 wait 处阻塞, 此时, 消费者线程 B 获得执行权, 更改了 flag(判断房间是否有人) 这个共享变量, 恰巧线程 A 在 wait 处醒来了(被线程B 的 notify唤醒), 不会再判断 if 条件, 直接向下执行.  

if 的危险之处在于, 当有多个生产者和消费者时, if 的条件只被判断了一次, 应该使用 while, 使得 while 代码块中的线程无论什么时候醒来, 都会判断一下循环条件.  

但是 while 由于不断循环造成死锁, notify()唤醒的是线程池中先休眠的线程, notifyAll() 唤醒的是线程池中所有线程, 最后修改成的`while + notifyAll`形式  

```java
 // 录入人员信息 - 存在线程安全(只录入姓名，性别未输入，被打断)
    public synchronized void set(String name,String sex){
        // 如果 Room 中已有人， 停止录入
        while (flag) {
            try {this.wait();} catch (InterruptedException e) {e.printStackTrace();} // 很有可能线程在这一步阻塞了
        }
        this.name = name;
        this.sex = sex;
        System.out.println("PeopleIn:"+name + "......." + sex);
        flag = true;
        // 唤醒线程
        this.notifyAll();
    }
```

使用 `notifyAll`,唤醒的是线程池中所有线程, 但是在多生产者-多消费者例子中, 生产者并不需要唤醒所有线程, 生产者生产完毕, 只需要唤醒所有**消费者线程**, 同样, 消费者消费完毕, 只需要唤醒所有**生产者线程**, 怎样实现只唤醒对方线程, 不唤醒本方线程?  

可以使用多个 synchronized 锁来实现, 生产者一个锁,消费者一个锁,每个锁里绑一个对象, 每个锁里对应一个`wait, notify`方法, 但是锁一多, 又易于死锁

1.5 版本的`Lock接口 + Condition接口`提供了显式的锁机制，将**等待唤醒机制进行封装**，使一个锁可以绑定**多个condition 对象**，从而完成唤醒对方线程的操作。

```java
 // 新建一个锁
    private Lock lock = new ReentrantLock();

    // wait，notify等方法都封装在 Condition 对象中，要通过 Lock 获取 Condition 对象
    // 新建两个锁
    private Condition condition_producer = lock.newCondition();
    private Condition condition_customer = lock.newCondition();
```
## 四. 一个多线程演进的过程
> synchronised 加锁 -- 单个生产者消费者 -- 多个生产者，消费者 --- Lock 锁机制替代 synchronized + while + notifyAll

单线程执行的时候, 为了提高程序运行效率, 引入了**多线程**, 但是多线程争抢 CPU 执行权, 争抢共享对象时, 带来了数据不一致的风险,   

于是, 引入了`synchronized`通过**锁机制**让每个线程单独使用共享对象, 可是程序中出现多个锁时, 又带来了死锁的风险,   

为了尽量避免死锁, 引入了线程通信, 通过**等待唤醒机制**, 唤醒沉睡的死锁 , 线程通信中有两种情况, 单个生产者消费者和多个生产者消费者, 前者可以使用`if + notify`的等待唤醒机制, 后者必须使用`while + notifyAll`的等待唤醒机制, 根本差别在于线程在 `wait`处醒来的时候, if 不会进行条件判断, while 会再次判断. 但是在多个生产者消费者中, 生产者执行完生产操作后, 只需要唤醒消费者线程, 不必要`notifyAll`唤醒所有线程, 怎样实现唤醒对方线程呢?  

实现唤醒对方线程, 可以使用两个锁, 每个锁绑定一个`wait notify`方法, 但是, 多个锁又会带来死锁风险, 于是引入**Lock接口 + Condition接口**代替**synchronized + while + notifyAll**, 使一个Lock锁中可以绑定多个condition对象, 从而实现唤醒对方线程.  

现在多使用Lock锁.  


卒.
